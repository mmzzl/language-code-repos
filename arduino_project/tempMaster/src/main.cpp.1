#define display_period 2000         //time of display volt target in milliseconds
#define autooff_time 5 * 60 * 1000  //time of auto turn off in milliseconds
#define MAX_temp 425                //if tempreture rises above this number, system will turn off the output to protect.

#include "SevSeg.h"
SevSeg sevseg;  //Instantiate a seven segment controller object
int out_ctrl = 3;
int red_led_pin = 5;
int temp_sensor_pin = A0;
int temp_set_pin = A1;
int left_pushbutton_pin = A3;
int right_pushbutton_pin = A2;
int ball_sw_pin = A4;
bool last_ball_sw_status = 0;
int setbias_pin = A6;
int temp_target = 220;
bool output_status = 1;  //default status is on
bool auto_turnoff_status = 0;
int lastPrintTime = 0;
int tempreture = 0;
int tempreture_bias = 0;
int last_temp_target = 0;
unsigned long last_displaytarget_time = 0;
unsigned long last_handlemove_time = 0;
int lastTime = -151;
int temp_display = 0;
int temp_display_count = 0;

void setup() {
  Serial.begin(115200);

  pinMode(temp_sensor_pin, INPUT);
  pinMode(temp_set_pin, INPUT);
  pinMode(out_ctrl, OUTPUT);
  pinMode(red_led_pin, OUTPUT);
  pinMode(left_pushbutton_pin, INPUT_PULLUP);
  pinMode(right_pushbutton_pin, INPUT_PULLUP);
  pinMode(ball_sw_pin, INPUT_PULLUP);  //detect handle movement
  digitalWrite(out_ctrl, HIGH);        //default status is on


  byte numDigits = 3;
  byte digitPins[] = { 11, 12, 13 };
  byte segmentPins[] = { 2, 4, 6, 7, 8, 9, 10 };
  bool resistorsOnSegments = false;      // 'false' means resistors are on digit pins
  byte hardwareConfig = COMMON_CATHODE;  // See README.md for options
  bool updateWithDelays = false;         // Default 'false' is Recommended
  bool leadingZeros = false;             // Use 'true' if you'd like to keep the leading zeros
  bool disableDecPoint = true;           // Use 'true' if your decimal point doesn't exist or isn't connected

  sevseg.begin(hardwareConfig, numDigits, digitPins, segmentPins, resistorsOnSegments,
               updateWithDelays, leadingZeros, disableDecPoint);
  sevseg.setBrightness(90);
}
int temp_sensor = 0;
unsigned long timer = 0;
int denoiseADC(int port) {
  int timesofdenoise = 1;
  digitalWrite(out_ctrl, HIGH);
  delay(1);
  int ans = 0;
  for (int i = 0; i < timesofdenoise; i++)
    ans += analogRead(port);
  digitalWrite(out_ctrl, output_status);

  return ans / timesofdenoise;
}

int getTempreture(int rawTemp) {

  return rawTemp + 25;
}

void loop() {
  static unsigned long timer = millis();  //use this to avoid use "millis()", in 100 miliseconds range
  static unsigned long a = 0;
  if (millis() - timer >= 100)  //every 0.1s refresh
  {
    timer += 100;
    lastTime = timer;
    if (auto_turnoff_status == 0)  //do not auto turn off
    {
      temp_target = getTempreture(map(analogRead(temp_set_pin), 0, 1023, 125, 350));
      //  Serial.println(volt);

      if ((last_temp_target != temp_target) && (last_temp_target != temp_target + 1) && (last_temp_target != temp_target - 1))  //which means that the angle of potentiometer has been changed
      {
        //      sevseg.setNumber(temp_target, 1);
        last_displaytarget_time = timer;
        last_handlemove_time = timer;
        //                Serial.println("A");
      }
      a = last_displaytarget_time + display_period;
      if (a > timer)  //within tempreture target display period
      {
        sevseg.setNumber(temp_target, 1);
        analogWrite(red_led_pin, map(a - timer, 0, 2000, 0, 150));
        //    Serial.print("last_displaytarget_time:");
        //    Serial.print(last_displaytarget_time);
        //  Serial.print(",");
        //Serial.print("timer:");
        //    Serial.print(timer);
        //    Serial.print(",");
        //          Serial.println("B");
      }

      else {
        if (!(timer % 1000))  //every 1s refresh display
        {
          temp_display /= temp_display_count;
          sevseg.setNumber(temp_display, 1);
          temp_display = 0;
          temp_display_count = 0;
        }

        analogWrite(red_led_pin, 0);
        //    Serial.println("C");
      }


      temp_sensor = getTempreture(denoiseADC(temp_sensor_pin)) + tempreture_bias;
      temp_display += temp_sensor;
      temp_display_count++;
      digitalWrite(out_ctrl, output_status);
      tempreture_bias = map(analogRead(setbias_pin), 0, 1024, -50, 50);
      if (temp_sensor < temp_target) output_status = 1;
      else if (temp_sensor > temp_target) output_status = 0;

    
    Serial.print("温度矫正量:");
    Serial.print(tempreture_bias);
    Serial.print(",");
    Serial.print("温度设定值:");
    Serial.print(temp_target);
    Serial.print(",");
    Serial.print("温度:");
    Serial.print(temp_sensor);
    Serial.print(",");
    Serial.print("输出状态:");
    Serial.println(output_status * 100);


      last_temp_target = temp_target;
    } else  //auto turn off
    {
      sevseg.setChars("OFF");
      output_status = 0;
      digitalWrite(out_ctrl, output_status);
      analogWrite(red_led_pin, 0);
    }
  }
  /*
  int t = millis();
  if (t > lastPrintTime + 150)  //every 0.15s refresh
  {
    lastPrintTime = t;
  }
*/
  int ball_sw_status = 0;
  ball_sw_status = digitalRead(ball_sw_pin);
  //  Serial.println(ball_sw_status);
  if (ball_sw_status != last_ball_sw_status) {
    last_ball_sw_status = ball_sw_status;
    last_handlemove_time = timer;
  }
  unsigned long handlemoved_time = timer - last_handlemove_time;  //how many milliseconds have been pased since last time the handle was moved
  if (handlemoved_time > autooff_time) auto_turnoff_status = 1;
  else auto_turnoff_status = 0;
  if (digitalRead(left_pushbutton_pin) == 0)  //if push button has been pushed, then turn on
  {
    auto_turnoff_status = 0;
    last_handlemove_time = timer;
  }
  if (digitalRead(right_pushbutton_pin) == 0)  //if push button has been pushed, then turn on
  {
    auto_turnoff_status = 0;
    last_handlemove_time = timer;
  }

  if (temp_sensor > MAX_temp)  //tempreture is too high, self-protection
  {
    int i = 0;
    sevseg.setChars("Err");
    output_status = 0;
    digitalWrite(out_ctrl, output_status);
    analogWrite(red_led_pin, 255 * ((timer / 500) % 2));  //blink red led
    last_handlemove_time = timer;
  }

  sevseg.refreshDisplay();  // Must run repeatedly
}


/// END ///
